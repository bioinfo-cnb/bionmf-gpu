/************************************************************************
 * Copyright (C) 2011-2013:
 *
 *	Edgardo Mejia-Roa(*), Carlos Garcia, Jose Ignacio Gomez,
 *	Manuel Prieto, Francisco Tirado and Alberto Pascual-Montano(**).
 *
 *	(*)  ArTeCS Group, Complutense University of Madrid (UCM), Spain.
 *	(**) Functional Bioinformatics Group, Biocomputing Unit,
 *		National Center for Biotechnology-CSIC, Madrid, Spain.
 *
 *	E-mail for E. Mejia-Roa: <edgardomejia@fis.ucm.es>
 *	E-mail for A. Pascual-Montano: <pascual@cnb.csic.es>
 *
 *
 * This file is part of bioNMF-mGPU..
 *
 * BioNMF-mGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BioNMF-mGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BioNMF-mGPU.  If not, see <http://www.gnu.org/licenses/>.
 *
 ***********************************************************************/



		<< BIONMF-GPU INSTALLATION GUIDE >>

This document shows how to install and compile bioNMF-GPU.

Index:
	1. Introduction.
	2. System requirements.
	3. Directory structure.
	4. Compiling bioNMF-GPU.
	5. Script API.
	6. Running tests and examples of use.
	7. Utilities.
	8. User interfaces.
	9. Issues/Troubleshooting.
	10. How cite bioNMF-GPU.

=============================

1. Introduction:

BioNMF-GPU implements the Non-negative Matrix Factorization (NMF) methodology making use of a Graphics-Processing Unit (GPU). This algorithm takes an input matrix (V) and returns two matrices, W and H, whose product is equal to V (i.e., V ∼ W*H). If matrix V has n rows and m columns, then dimensions for output matrices, W and H, will be n x k and k x m respectively, where k is the provided factorization rank.

Driven by the ever-growing demands of the game industry, where numerous algebraic operations are required to draw images on the screen, Graphics-Processing Units (GPUs) have evolved from simple graphics-drawing devices into highly-parallel and programmable systems that largely outperforms any conventional processor. This GPU implementation of the NMF algorithm has been developed using the NVIDIA's Compute-Unified-Device-Architecture (CUDA) programming model, which represents the GPU as a programmable co-processor.

=============================

# 2. System requirements:

For Windows systems, we provide an executable file compiled with generic code for GPU devices of [compute capability](https://developer.nvidia.com/cuda-gpus) 1.0, 2.0, and 3.0. Note that such code is less faster than an architecture-specific version. For other operating systems (e.g., Linux or Mac OS X) and/or GPU architectures, you need to install the [CUDA Toolkit](https://developer.nvidia.com/cuda-downloads/) in order to compile a customized version of bioNMF-GPU.

CUDA software can be downloaded at <https://developer.nvidia.com/cuda-downloads/>. BioNMF-GPU requires version 4.2, or greater.

Depending on your operating system, the CUDA Toolkit has the following dependencies, among others:

	* Linux:
		+ GNU C/C++ Compiler (gcc / g++).
		+ GNU Make.

	* Mac OS X:
		+ The gcc or Clang compiler and toolchain installed using [Xcode](https://developer.apple.com/technologies/tools/).

	* Windows:
		+ [Microsoft Visual Studio](http://www.microsoft.com/visualstudio/). The full version is required, not the *Express* edition.

An exhaustive list of requirements, as well as detailed installation instructions can be found on the "Getting Starting" guides for [Linux](http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-linux/index.html), [Mac OS X](http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/index.html), and [Windows](http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-microsoft-windows/index.html), respectively. Finally, additional (possibly important) information can also be found on the [*Release Notes*](http://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html).

=============================

3. Directory structure:

A) Folders:

After extracting the compressed file, you should see the following folders:
	* doc:		Installation and User guides.
	* src:		Source code.
	* include:	Header files.
	* test:		Example of a valid input matrix.

In addition, there is a 'Makefile' with the compilation directives. This file must be customized before the compilation process (see Section 4 below).

-------------------

B) Source-code directory structure:

The src folder is organized as follow:

	* Main-program files:
		+ bioNMF-GPU.c:			Main program (single-GPU version).
		+ MPI / bioNMF-GPU-MPI.c:	Main program (multi-GPU version).

	* CUDA files:
		+ nmf_routines.cu:		NMF-related operations.
		+ matrix_operations.cu:		Algebraic operations and data transfers on matrices.
		+ GPU_kernels.cu:		CUDA kernels (i.e., device code).
		+ GPU_setup.cu:			GPU set-up and management routines.
		+ timing.cu:			Timing and profiling routines.

	* Other files (C99 code):
		+ matrix / matrix_io.c:		 Functions to read/write data matrices.
		+ matrix / matrix_io_routines.c: Auxiliary I/O routines.

	* Utility programs for ASCII-Binary file conversion (C99 code):
		+ matrix / tools / file_converter.c
		+ matrix / tools / native_file_converter.c
		+ matrix / tools / generate_matrix.c: Generates a matrix with random values in text or binary format.


The include folder is similarly organized:
	+ real_type.h:		Floating-point data definition.
	+ index_type.h:		Data type used for array index.
	+ nmf_routines.cuh
	+ matrix_operations.cuh
	+ GPU_kernels.cuh
	+ GPU_setup.cuh
	+ timing.cuh
	+ matrix / matrix_io.h
	+ matrix / matrix_io_routines.h

=============================

4. Compiling bioNMF-GPU.

NOTE: Part of the C code (e.g., matrix I/O operations) is based on the ISO-C99 standard. Therefore, support for such language must be enabled on the selected C/C++ compiler. The provided `Makefile` file already enables it for `gcc` by setting the flag `-std=c99`.


A) Compilation Settings:

Before compiling bioNMF-GPU, it is necessary to check and customize the following parameters located at the begining of 'Makefile':


	CUDA_INSTALL_PATH:	Path to CUDA Toolkit runtime. Default: '/opt/cuda/'

	CUDA_SDK_PATH:		Path to CUDA Source Development Kit (SDK). Default: '/opt/cuda_sdk/'

	GPU-architecture specific options and their default values:
		SM_VERSIONS:	13
		GENCODE_ARCH:	-gencode=arch=compute_13,code=sm_13
		GENCODE_SM10:
		GENCODE_SM20:

	C_COMMON_FLAGS:		C and C++ common compiler flags. Default: '-pipe -fomit-frame-pointer -mfpmath=sse -march=native -msse4.2 -Wall -O3'



IMPORTANT NOTE: Some parts of the C code (e.g., matrix I/O operations) require a C99-enabled compiler. Therefore, the '-std=c99' flag MUST BE PRESENT in the 'CFLAGS' options string (it is already set by default).







A) Makefile options

The following parameters affect the compilation process:

	SINGLE:			If set to 1, uses single-precision data (i.e., 'float').
				Else, uses double-precision data (i.e., 'double')

	CHECK_RESULTS:		Set to 1 to compute the "distance" between W*H and V after the algorithms finishes.

	FAST_MATH:		Set to 1 to use less-precise faster math functions.

	TIME:			Set to 1 to show total elapsed time.

	TRANSF_TIME:		Set to 1 to show time elapsed on data transfers.

	KERNEL_TIME:		Set to 1 to s Show time elapsed on kernel code.

	CONVERGENCE_TIME:	Set to 1 to show time elapsed performing the convergence test.

	SYNC_TRANSF:		Set to 1 to perform SYNCHRONOUS data transfers.

	FIXED_INIT:		Set to 1 to make use of fixed initial values for W and H. Useful for debugging.

	DBG:			Set to 1 for VERBOSE and DEBUG mode (prints A LOT of information).

NOTES:
	* ONLY some of these options affect the compilation of utility programs (e.g., 'SINGLE').

	* Options 'SINGLE', 'CHECK_RESULTS', 'FAST_MATH', and 'TIME' are ENABLED by default. You can override them by passing the respective values on the command line (see below, section 4.B), or by customizing 'Makefile'.




Other NVCC-related options:

	verbose:		Set to 1 to show internal compiler invocations and commands. Default: 0.

	nvcc_warn_verbose:	Set to 1 to show all warnings in CUDA code. Default: 0.

	ptxas:			Set to 1 to show all kernel (i.e., GPU-specific code) warnings. Default: 0.

	keep:			Set to 1 to keep all intermediate code files.

----------------------------

Makefile rules and options:


Makefile defines the following rules:

	all:		Executes 'target', 'converters', and 'clean' rules. THIS IS THE DEFAULT.

	target:		Compiles the main program.

	converters:	Compiles the utilities programs.

	clean:		Removes all object and intermediate code from the 'bin' directory (excluding all executable files).

	clobber:	Executes 'clean' and removes the main-program executable file.

	clobber_conv:	Similar to 'clobber' but removes the utility-programs executable files.


Therefore, to completely remove all files under the 'bin' directory, please execute the following command:
$> make clobber clobber_conv




----------------------------


B) Compilation Process and Generated files:


To compile bioNMF-GPU and utility programs, you just need to execute at the prompt:
$> make [ all ]

Makefile arguments, as well as other options, can be specified as follows:
$> make SINGLE=1 FAST_MATH=1 [...]




-------------------

C) Directory structure for 'bin' folder:

	* bin/<OS>/release/:		- Executable files.
	* bin/obj/<CPU_arch>/release/:	- C/C++/CUDA object code.
	* bin/<OS>/cubin-data/:		- CUBIN files.
	* bin/<OS>/pxt-data/:		- PTX code (i.e., assembler of CUDA Kernels).

Notes:
	<OS> refers to the target Operating System (e.g., 'linux').
	<CPU_arch> denotes the target CPU architecture (e.g., 'x86' or 'x86_64').
	Only the first folder ('bin/<OS>/release/') is important. All other folders can be safety removed after compilation.



Without arguments (or with 'all'), it will generate several files under the 'bin/<OS>/release/' folder:

	* bin/<OS>/release/bioNMF-GPU

	* bin/<OS>/release/file_converter

	* bin/<OS>/release/native_file_converter

<OS> refers to the target Operating System (e.g., 'linux').




Optionally, some additional utilities & testing programs can be generated with:
$> make [...] utils

	* file_converter - Binary-text input file conversions.
	* native_file_converter - 'Native' binary - text input file conversions.
	* generate_matrices - Program to generate synthetic input files.
	* test_matrix_io - Test functions for reading/writing input files.
	* test_orderconsensus - Test Consensus Ordering step.

Note: 'Native binary' means system's precision (float/double) and byte-ordering (big/little endian).
	'Binary' means double-precision and little-endian.


=============================

6. Script API.

Please see <BIONMF_PATH>/script/doc/config_and_user_guide.txt


=============================

7. Running tests and examples of use.

Please see <BIONMF_PATH>/script/doc/config_and_user_guide.txt


=============================

8. Utilities

In addition to bioNMF-GPU, there are some utilities programs to make easier working with input files. It includes two programs for binary-text file conversion, another to generate input matrices with random data (useful for testing bioNMF-GPU) and several testing programs.

-----------------------------

A) src/matrix/io/file_converter.c
	Program to perform binary-text file conversions according to the arguments.
Usage:
	file_converter <filename> <file_is_binary> [<has_numeric_column-headers> [<hasn_umeric_row-labels> [<save_as_native-binary>]]]

Notes:
	* 'Native binary' refers to system's precision (float/double) and byte-ordering (big/little endian) binary format.
	  It is used as internal format for input and intermediate files. 'Binary' refers to double-precision and little-endian.
	* See valid input file formats in <BIONMF_PATH>/doc/user_guide.txt, section 3.
	* There are some examples of valid input matrices under the <BIONMF_PATH>/test/data folder.

-----------------------------

B) src/matrix/io/native_file_converter.c
	Performs native-binary - text file conversions.
Arguments:
	<filename> <file_is_native-binary> [<has_numeric_column-headers> [<hasn_umeric_row-labels> [<save_as_non-native-binary>]]]

Notes:
	* 'Native binary' refers to system's precision (float/double) and byte-ordering (big/little endian) binary format.
	  It is used as internal format for input and intermediate files. 'Binary' refers to double-precision and little-endian.
	* See valid input file formats in <BIONMF_PATH>/doc/user_guide.txt, section 3.
	* There are some examples of valid input matrices under the <BIONMF_PATH>/test/data folder.

-----------------------------

C) src/bionmf/generate_matrices.c
	Program to generate synthetic input files.
Arguments:
	<directory_to_save_files> <nrows> <ncols> [ <set_labels> [<kStart> [<kEnd> [<nRuns>]]] ]

Generates R matrices W and H of size <nrows> x <K> and <K> x <ncols>, respectively, where R = (kEnd-kStart+1)*nRuns and K=[kStart..kEnd]
That is, generates initialization data for all matrices W and H computed among all runs on all factorization ranks. By default, bioNMF-GPU initializes all matrices W and H with random values. This program is useful to test bioNMF-GPU by providing "known" initial values for such matrices.

If <kStart> is zero, or is not specified, it outputs a single matrix of size <nrows>-by-<ncols>. Useful to generate a synthetic input matrix.


-----------------------------

D) src/matrix/io/test_matrix_io.c
	Test functions for reading/writing input files.
Arguments:
	<filename> <file_is_binary> <has_numeric_column-headers> <hasn_umeric_row-labels> <transpose> [<online-limits_filename>]

Tests I/O methods in <BIONMF_PATH>/src/matrix/io/matrix_io.c. First, it reads the input matrix according to the given arguments, It includes transposing and applying additional limits on matrix size and other parameters (this is intended for online public versions). Then, it shows the file contents and saves two copies: in binary and in text file formats. Finally, it reads both files and show their contents, which should not differ from the input file.

If this program is compiled with the directive '-DDEBUG_TEST_READ_FILE' it just read a text file and shows all its content as it is being processed. This is useful to test row-labels and column-headers recognition.


-----------------------------

E) src/bionmf/sample_classification/orderconsensus/test_orderconsensus.c
	Test Test Consensus Ordering step.
Arguments:
	<filename> <M> <K>,
where M is the number of columns (samples).

This program tests all action performed in the consensus-ordering (sub-) step. It reads a Consensus matrix and computes the Cophenetic Correlation Coefficient (CCC) value for the given factorization rank (K). It also generates all outputs of the "Sample-Classification" analysis method.

NOTE: Input data must be a (M*(M-1)/2)-length vector stored in a single text line WITHOUT any kind of labels, where M is is the number of columns of a valid input matrix for bioNMF-GPU.


=============================

9. User interfaces

	* Web interface: Please see installation guide located at web/doc/installation_guide.txt file.
	* Web services interface: Please see installation guide located at webservice/doc/installation_guide.txt file.

=============================

10. Issues/Troubleshooting.

	A) Catastrophic error: could not set locale "" to allow processing of multibyte characters.
	B) /usr/include/limits.h(125): catastrophic error: could not open source file "limits.h"
	C) /usr/include/bits/stdio2.h:96: sorry, unimplemented: inlining failed in call to ‘fprintf’:
	   redefined extern inline functions are not considered for inlining
	D) Problems with postprocess_images.ctf (MATLAB).

Notes:
	For troubleshooting on user intefaces, please see specific guides.
	For troubleshooting when testing, please see <BIONMF_PATH>/script/doc/config_and_user_guide.txt.


-------------------

A) Catastrophic error: could not set locale "" to allow processing of multibyte characters

This issue seems to be related with Intel's icc.

Please set your LANG environment variable to en_US.ISO-8859-15

-------------------

B) /usr/include/limits.h(125): catastrophic error: could not open source file "limits.h"

This issue seems to be related with Intel's icc 10.1.015.

Please comment all "#include <limits.h>" lines and define the INT_MAX constant in the source code.

Example:

// #include <limits.h>
#ifndef INT_MAX
	#define INT_MAX 2147483647
#endif


Some files affected by this issue:

include/bionmf_common.h
include/matrix/io/matrix_io.h
include/matrix/io/config_file.h
src/preprocess.c
src/bionmf/sample_classification/orderconsensus/test_orderconsensus.c


-------------------

C) /usr/include/bits/stdio2.h:96: sorry, unimplemented: inlining failed in call to ‘fprintf’:
   redefined extern inline functions are not considered for inlining

This issue seems to be related with GCC's '-combine' option. Please do not use it.


-------------------

D) Problems with postprocess_images.ctf (MATLAB).

As of Matlab R2008a, CTF data is automatically embedded directly in the code. In order to override this default functionality, please add the "-C" option to the CFLAGS_MATLAB variable in the Makefile (section 'Compiler -- Matlab C Compiler').

Another option, is to insert
@touch $(BIN_POST_IMAGES)/$@.ctf
to the postprocess_images rule, just before the '@mv $(BIN_POST_IMAGES)/$@.ctf $(BIN_POST_IMAGES)/$@ $(BIN)' command.


=============================

11. How to cite bioNMF-GPU.

If you use this software, please cite the following work:

E. Mejía-Roa, P. Carmona-Saez, R. Nogales, C. Vicente, M. Vázquez, X. Y. Yang, C. García, F. Tirado and A. Pascual-Montano. "bioNMF-GPU: a web-based tool for nonnegative matrix factorization in biology". Nucl. Acids Res. 2008, 36 (suppl 2, Web Server issue), W523-W528. doi:10.1093/nar/gkn335.
http://nar.oxfordjournals.org/cgi/content/full/36/suppl_2/W523
http://bionmf.dacya.ucm.es
