##########################################################################
#
# NMF-mGPU - Non-negative Matrix Factorization on multi-GPU systems.
#
# Copyright (C) 2011-2015:
#
#	Edgardo Mejia-Roa(*), Carlos Garcia(*), Jose Ignacio Gomez(*),
#	Manuel Prieto(*), Francisco Tirado(*) and Alberto Pascual-Montano(**).
#
#	(*)  ArTeCS Group, Complutense University of Madrid (UCM), Spain.
#	(**) Functional Bioinformatics Group, Biocomputing Unit,
#		National Center for Biotechnology-CSIC, Madrid, Spain.
#
#	E-mail for E. Mejia-Roa: <edgardomejia@fis.ucm.es>
#	E-mail for A. Pascual-Montano: <pascual@cnb.csic.es>
#
#
# This file is part of NMF-mGPU.
#
# NMF-mGPU is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# NMF-mGPU is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with NMF-mGPU. If not, see <http://www.gnu.org/licenses/>.
#
##########################################################################

##########################################################################
#
# Makefile for NMF-mGPU on UNIX systems.
#
# List of available goals:
#
#	all:		DEFAULT target. Compiles all programs, EXCEPT the
#			multi-GPU version.
#
#	all_programs:	Compiles all programs, including the multi-GPU version.
#
#	multi_gpu:	Compiles the multi-GPU version. Target NOT compiled by
#			default.
#
#	single_gpu:	Compiles the single-GPU version.
#
#	tools:		Compiles some utility programs.
#			This target does NOT require any CUDA-related software
#			or configuration. In addition, it is NOT necessary to
#			specify the parameter 'SM_VERSIONS'.
#
#
# Other useful targets:
#
#	clean:		Removes the folder containing all object (".o") files.
#			Executable code is not affected.
#
#	clean_single_gpu, clean_multi_gpu, clean_tools:
#			Removes object files generated by the corresponding
#			target. Executable code is not affected.
#
#	clobber, distclean, realclean:
#			Removes all directories containing executable and object
#			files.
#
#	clobber_single_gpu, clobber_multi_gpu, clobber_tools:
#			Removes executable and object files generated by the
#			corresponding target.
#
#	help:		Prints this help message.
#
#	help_sm_versions:
#			Prints a detailed description of the 'SM_VERSIONS'
#			parameter.
#
#	help_tools:	Prints a short description of available utility programs.
#
#
# List of available parameters:
#
#	SM_VERSIONS:	Target GPU architecture(s). This parameter may be an
#			environment variable or an argument. Device code will be
#			generated for the specified "Compute Capability(-ies)" (CC).
#			For instance, SM_VERSIONS="10-13  30  PTX35":
#			* Generates device-specific executable code for CC 1.3,
#			  using only the basic functionality present on CC 1.0.
#			* Generates device-specific executable code for CC 3.0,
#			  using all available features on such architecture.
#			* Emits PTX code for CC 3.5, which can be later
#			  compiled and executed by any current or future device,
#			  with a similar or higher Compute Capability.
#			To generate device-specific executable code for CC 2.1,
#			please specify it as: '20-21'.
#			See a more detailed description of this parameter by
#			executing:
#				make  help_sm_versions
#			This parameter is currently ignored by target 'tools'.
#
#	SINGLE:		If set to '1', uses single-precision data (i.e., 'float').
#			Otherwise, uses double precision (i.e., 'double').
#			WARNING: On Compute Capability < 1.3, double-precision
#			arithmetic operations are demoted to single precision.
#			In addition, accesses to shared memory will be split
#			into two requests with bank conflicts.
#
#	UNSIGNED:	Uses UNSIGNED integers for matrix dimensions, which may
#			generate faster code. Nevertheless, please note that
#			CUBLAS library functions use SIGNED-integer parameters.
#			Therefore, matrix dimensions must not overflow such data
#			type. An error message will be shown if this happens.
#
#	FAST_MATH:	Uses less-precise faster math functions.
#
#	TIME:		Shows total elapsed time.
#
#	TRANSF_TIME:	Shows time elapsed on data transfers.
#
#	KERNEL_TIME:	Shows time elapsed on kernel code.
#
#	COMM_TIME:	Shows time elapsed on MPI communications.
#
#	SYNC_TRANSF:	Performs SYNCHRONOUS data transfers.
#
#	FIXED_INIT:	Makes use of "random" values from a fixed seed.
#
#	CPU_RANDOM:	Generates random values from the CPU host, not from the
#			GPU device.
#
#	DBG:		VERBOSE and DEBUG mode (prints A LOT of information).
#			It implies CC_WARN_VERBOSE, NVCC_WARN_VERBOSE, and
#			PTXAS_WARN_VERBOSE set to '1'.
#
#	VERBOSE:	Command-line verbosity level. Valid values are '0'
#			(none), '1' (shows make compilation commands), '2'
#			(shows all make and shell commands), and '3' (shows all
#			make, shell, and NVCC commands).
#
#	CC_WARN_VERBOSE:
#			Shows extra warning messages on programs compiled with
#			CC. Please note that it may include "false-positive"
#			warnings.
#
#	NVCC_WARN_VERBOSE:
#			Shows extra warning messages on programs compiled with
#			NVCC. Please note that it may include "false-positive"
#			warnings. It implies PTXAS_WARN_VERBOSE set to '1'.
#
#	PTXAS_WARN_VERBOSE:
#			Shows PTX-specific compilation warnings.
#
#	KEEP_INTERMEDIATE:
#			Keeps temporary files generated by NVCC.
#
#
# Default compilers can be overridden with following parameters or environment
# variables:
#
#	CC:		Compiler for ISO-C and CUDA-host code. Used also in the
#			linking stage of targets "single_gpu" and "tools".
#			Supported compilers: 'gcc' and 'clang'.
#			Default values: 'clang' for Darwin (i.e., Mac OS X); 'gcc', otherwise.
#
#	NVCC:		Compiler for CUDA device code. Default value: 'nvcc'.
#			WARNING: Paths containing whitespace characters must be
#			surrounded by single/double quotes, *AND* be properly
#			escaped with '\\'.
#			For instance:
#				NVCC:="/opt/cuda\ toolkit/bin/nvcc"
#
#	MPICC:		Compiler for MPI code. Default value: 'mpicc'.
#
#
# Additional flags, not affected by other input parameters, can be specified
# through the following parameters or environment variables:
#
#	CPPFLAGS, CFLAGS, INCLUDES, LDFLAGS, LDLIBS:
#			Additional flags included in all targets.
#			NOTE: "CFLAGS" is IGNORED by NVCC. Instead, please make
#			use of 'CXXFLAGS' and/or 'NVCC_CFLAGS' (see below).
#
#	CXXFLAGS:	Additional options controlling the NVCC's internal
#			compiler. Each word is automatically prefixed by
#			'--compiler-options' in the command line.
#			Parameter ignored on files not compiled with NVCC.
#
#	NVCC_CPPFLAGS, NVCC_CFLAGS, NVCC_INCLUDES:
#			Additional options for NVCC.
#
#	OPENCC_FLAGS:	Additional flags for 'nvopencc', which generates PTX
#			(intermediate) code on devices of Compute Capability 1.x.
#			Parameter ignored on newer GPU architectures.
#
#	PTXAS_FLAGS:	Additional flags for PTX code compilation, which
#			generates the actual GPU assembler.
#
#	MPICC_CPPFLAGS, MPICC_CFLAGS, MPICC_INCLUDES, MPICC_LDFLAGS,
#	MPICC_LDLIBS:
#			Additional flags for MPICC.
#
###################
#
# Tool programs:
#
# In addition to "NMF-mGPU", there are some utility programs to make easier
# working with input files. It includes a program for binary-text file conversion,
# and another to generate input matrices with random data (useful for testing).
#
# NOTE: Tool programs do NOT make use of the GPU device. They have been
# implemented in pure ISO-C language, so all operations are performed on the HOST
# (i.e., the CPU). Therefore, they do NOT require any CUDA-related option,
# configuration or software. In addition, it is NOT necessary to specify the
# Makefile parameter "SM_VERSIONS".
#
# 1) Binary-text file converter:
#    Since "NMF-mGPU" accepts input matrices stored in a binary or ASCII-text
#    file, this program allows file conversion between both formats. For binary
#    files, there are two sub-formats: "native" and "non-native".
#
#	* "Non-Native" mode: Matrix data are stored using DOUBLE-precision values,
#	  and 32-bits UNSIGNED integers for matrix dimensions. If necessary, all
#	  values must be converted to LITTLE-endian format before writing to
#	  file. Finally, the file also contains a "binary signature", which will
#	  be checked when reading to make sure it is a valid input file.
#
#	* "Native" mode: Matrix data are stored in RAW format according to the
#	  selected compilation parameters. That is, 'float' values if the
#	  program was compiled in SINGLE-precision mode (i.e., if the Makefile
#	  parameter "SINGLE" was set to '1'), and 'double' otherwise. Matrix
#	  dimensions are stored in a similar way: 'unsigned int' if "UNSIGNED" was
#	  set to '1', and '[signed] int' otherwise. Finally, all data is stored
#	  with the native endianness.
#
# 2) Matrix generator:
#    This program generates a data matrix with non-negative random values. The
#    output file can be used as a valid input dataset for NMF-mGPU. You can
#    select the output matrix dimensions, as well as the highest possible random
#    number (i.e., all values will be generated in the closed range between 0.0
#    and the selected value, both inclusive). The output matrix can be written
#    as ASCII text, or in a binary file (in any of the binary modes described
#    above).
#    WARNING: Output matrix will NOT contain any tag (i.e., neither of row
#    labels, column headers nor a description string), just numeric data.
#
#################################################################################

# Default Values:

# Single precision (i.e., float). Set to '0' for double-precision data.
SINGLE := 1

# Unsigned integers for matrix dimensions.
UNSIGNED := 1

# Less-precise, faster math functions.
FAST_MATH := 1

# Target GPU architectures.
ifeq (${SM_VERSIONS},)

	#############
	 #
	 # There are three ways to specify target architecture(s) in the SM_VERSIONS
	 # parameter:
	 #
	 # 1) Device-specific features & code (i.e., PTX and executable code, with SIMILAR
	 #    Compute Capability):
	 #
	 #    Emits PTX assembler code, which is then compiled into executable
	 #    instructions just for the given "Compute Capability(-ies)" (CC). Since the
	 #    former is just an intermediate code (i.e., it is NOT retained in the output
	 #    file), and the latter is generated with a device-specific binary format, the
	 #    program may not be compatible with other GPU architectures. That is, any
	 #    given CC value, "XY", is translated to the following NVCC option:
	 #    "--generate-code=arch=compute_<XY>,code=sm_<XY>"
	 #
	 #    For instance, 'SM_VERSIONS="13  35"' generates executable code just for
	 #    devices of Compute Capability 1.3 and 3.5, respectively. GPU devices with
	 #    other CC values, such as 1.1 or 2.0, may not be able to execute the program.
	 #
	 #    NOTE:
	 #    For devices, such as 2.1, that do not have a similar PTX CC number, please
	 #    specify the nearest lower value ("2.0", for the previous example) by using
	 #    the dashed-separated form below.
	 #
	 #
	 # 2) Generic features, device-specific code (i.e., PTX and executable code, with
	 #    DIFFERENT Compute Capabilities):
	 #
	 #    This is a generalization of the previous form. Here, different "Compute
	 #    Capabilities" (CC) can be specified for both, PTX and executable code,
	 #    separated by a dash. That is, "XY-WZ" (with XY <= WZ), emits PTX assembler
	 #    code for CC "X.Y", which is then compiled into executable instructions for
	 #    a device of CC "W.Z". The former, determines the target ARCHITECTURE (i.e.,
	 #    the available hardware/ software features and functionality). The latter,
	 #    specifies the target DEVICE in terms of binary code format.
	 #
	 #    Similarly as above, no PTX code is embedded in the output file, so the
	 #    program may not be compatible with other GPU device models. That is, the
	 #    previous expression is translated to the following NVCC option:
	 #    "--generate-code=arch=compute_<XY>,code=sm_<WZ>"
	 #
	 #    Note that "XY-XY" is equivalent to just specify "XY" as in the previous form.
	 #    On the other hand, if XY < WZ, the program is still compiled for the target
	 #    device (i.e. CC "W.Z"), but it will only make use of features available on
	 #    CC "X.Y", discarding any functionality introduced since.
	 #
	 #    NOTE:
	 #    As stated above, please use this form to specify target devices, such as
	 #    CC 2.1, that do not have a similar PTX CC number (so, a lower value must
	 #    also be biven). Example: '20-21'.
	 #
	 #    For instance, 'SM_VERSIONS="10-13  20-21"':
	 #
	 #	* Generates executable code for a device of CC 1.3, with the basic
	 #	  features that are available on CC 1.0. In particular, it discards all
	 #	  support for double-precision floating-point data, introduced on CC 1.3.
	 #	* Compiles the algorithm with the features and functionality available
	 #	  on CC 2.0, and generates a binary image for a device of CC 2.1.
	 #	* Since no PTX code is retained in the output file, the program may not
	 #	  compatible with other GPU devices (e.g., CC 3.0).
	 #
	 #
	 # 3) Generic features and "code":
	 #
	 #    Emits PTX assembler code for the given "Compute Capability" (CC), and
	 #    embeds it into the output file. No executable code is generated. Instead,
	 #    the former is dynamically compiled at runtime according to the actual GPU
	 #    device. Such process is known as "Just-in-Time compilation" (JIT).
	 #
	 #    To specify a target architecture in a such way, please use the word 'PTX'
	 #    followed by the target Compute Capability.
	 #    That is,
	 #		"PTX<wz>"
	 #
	 #    generates PTX code for Compute Capability "w.z", and embeds it into the
	 #    output file. Such code can be later compiled and executed on any device,
	 #    with a similar or greater CC value. Similarly as previous forms, the
	 #    expression above is translated to the following NVCC option:
	 #    "--generate-code=arch=compute_<wz>,code=compute_<wz>".
	 #
	 #    Note, however, that JIT compilation increases the startup delay. In
	 #    addition, the final executable code will use just those architectural
	 #    features that are available on CC "w.z", discarding any functionality
	 #    introduced since.
	 #
	 #    For instance, 'SM_VERSIONS="PTX10  PTX35"':
	 #
	 #	* Emits PTX code for the first CUDA-capable architecture (i.e., CC 1.0).
	 #	  Therefore, the program can be later dynamically compiled and executed
	 #	  on ANY current or future GPU device. Nevertheless, it will only use
	 #	  the (very) basic features present on such architecture.
	 #	* Generates PTX code that can be later compiled and executed on devices
	 #	  of CC 3.5, or higher.
	 #	* Any device prior to CC 3.5 (e.g., 1.3, 2.1, or 3.0), will execute the
	 #	  basic CC 1.0 version.
	 #
	 #    This parameter is currently ignored on the 'tools' target.
	 #
	#############


	# Compiles device-specific code for the following Compute Capabilities:
	#
	# WARNING:
	#	* On Compute Capability < 1.3, double-precision arithmetic operations
	#	  are demoted to single precision. In addition, accesses to shared
	#	  memory will be split into two requests with bank conflicts.
	#	* Compute Capabilities 1.x are DEPRECATED since CUDA Toolkit version 7.0
	#	  (Compute Capability 1.0 since CUDA version 6.0).
	#
	SM_VERSIONS := 20 30 35

	# Compiles specific code for Compute Capability 2.1. Comment to disable.
	SM_VERSIONS += 20-21

	# This line provides compatibility with future GPU architectures. Comment to disable.
	SM_VERSIONS += PTX35
endif


########################################
# Source code directory and filenames
########################################

# Directory tree
# WARNING: Please, do NOT use whitespace characters in folder names.
srcdir	   := src
includedir := include
bindir	   := bin
objdir	   := obj

# Matrix I/O Operations directory name
matrix_io_dirname := matrix_io

# Tools directory name
tools_dirname := tools
tools_objdir  := $(objdir)/$(tools_dirname)
tools_bindir  := $(bindir)/$(tools_dirname)

# Source files
multi_gpu_FILE	  := NMF_mGPU.c
single_gpu_FILE	  := NMF_GPU.c
tools_FILES	  := $(tools_dirname)/file_converter.c  $(tools_dirname)/generate_matrix.c
cuda_device_FILES := GPU_kernels.cu
cuda_host_FILES	  := timing.c  GPU_setup.c matrix_operations.c NMF_routines.c
iso_c_FILES	  := common.c  $(matrix_io_dirname)/matrix_io_routines.c  $(matrix_io_dirname)/matrix_io.c


########################################
# Miscellaneous Utilities and Variables
########################################

# Shell
SHELL := /bin/sh

# Makes a directory:
MKDIR := mkdir

# Makes a (possibly existing) directory
# NOTE: Replace it by a custom function if your system does not support '-p'
MKDIR_P = ${MKDIR} -p $(1)

# Removes an entire directory with all its content:
RMDIR := ${RM} -r

# OS Name
os_lower := $(strip $(shell uname -s 2>/dev/null | tr "[:upper:]" "[:lower:]"))

# Flags to detect 32-bits or 64-bits OS platform
os_size := $(strip $(shell uname -m | sed -e "s/i.86/32/" -e "s/x86_64/64/" -e "s/armv7l/32/"))

# Whitespace
empty :=
space := $(empty) $(empty)

# Always keeps all intermediate files (unless the 'clean' target is explicitly requested)
.SECONDARY:

.SUFFIXES:
.SUFFIXES: .c .o .h .cu .cu.o .cuh .d .sentinel

###########

# Miscellaneous function for file and directory searches:


# Replaces whitespace characters by a "weird" string.
weird_string := '\$\%\&'
subst_whitespaces = $(subst $(space),$(weird_string),$(1))


# Restores whitespace characters.
restore_whitespaces = $(subst $(weird_string),\ ,$(1))


# Escapes whitespace characters.
escape_whitespaces = $(subst $(space),\ ,$(strip $(1)))


# Returns all directories in PATH.
# Replaces any existing whitespace in folder names by a "weird" string.
# Then, replaces colons (:) by spaces.
dirs_in_PATH = $(subst :, ,$(call subst_whitespaces,${PATH}))


# Checks if the file $(1) exists in the folder $(2)
# Restores any previous whitespace before checking for existence.
# NOTE:
#	We use "wildcard", since other similar functions (e.g., realpath) ignore
#	escaped characters. However, "wildcard" removes the escapes sequences from
#	the result, so they have to be escaped again...
check_existence = $(call escape_whitespaces,$(wildcard $(call restore_whitespaces,$(2))/$(1)))


# Searches for the first instance of $(1) in PATH.
# Folder names with spaces ARE supported. The result is returned in $(2).
# This is similar to '$(shell which $(1))', but that function is not portable.
#
define whitespace_pathsearch

	# This temporary variable is used to ignore other existing instances of $(1).
	$(eval tmp := $(empty))

	# Once tmp is non-empty, no more calls to "check_if_exists" are performed.
	$(foreach folder,$(call dirs_in_PATH),$(if $(value tmp),,$(eval tmp := $(call check_existence,$(1),$(folder)))))

	# Sets the result
	$(eval $(2) := $(tmp))

	# Removes the temporary variable
	undefine tmp
endef

# Searches for the first instance of $(1) in PATH.
# WARNING: It does NOT support whitespace characters.
fast_pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,${PATH}))))

####

# Applies the given function (e.g., dir(), notdir()) to a path with whitespace characters:
# Substitutes any space, applies the function, and restores remaining spaces.
# Usage: $(call whitespaced_path,$(function),$(path))
whitespaced_path = $(call restore_whitespaces,$(call $(1),$(call subst_whitespaces,$(2))))



########################################
# Compiler options
########################################

# Default C compiler:
ifeq ("$(os_lower)","darwin")
	default_CC := clang
else
	default_CC := gcc
endif

ifneq ($(filter default undefined,$(origin CC)),)
	override CC := $(default_CC)
else
	# Just in case the user tried to undefine CC by assigning an empty value
	# (rather than use the "unset" command).
	ifeq (${CC},)
		override CC := $(default_CC)
	endif
endif

cc_name := $(or $(findstring gcc,${CC}),$(findstring clang,${CC}),$(strip $(notdir ${CC})))


#######

# NOTE: Some of the following variables are recursively expanded (i.e., they use '=' rather than ':=').

# Common C/C++ flags (i.e., common flags for CC and NVCC's internal compilers).
common_CFLAGS = -O3 -pipe -fPIC -fPIE -D_GNU_SOURCE -fpch-preprocess -Wall -fstrict-aliasing -Winline -Wcast-align \
		$($(cc_name)_$(os_lower)_common_CFLAGS) -Wstrict-overflow=5 -Wno-invalid-pch -Wno-unused-parameter \
		-Wno-unused-variable -m$(os_size)


# Flags for faster code.
common_fast_CFLAGS = $($(cc_name)_$(os_lower)_common_fast_CFLAGS) -ffast-math -funroll-loops -mfpmath=sse -msse4.2

common_CPPFLAGS :=
common_LDFLAGS  := -pie


# Flags for (non-C++) programs compiled with CC (in addition to those in common_CFLAGS).
cc_CFLAGS = -std=c99 $($(cc_name)_$(os_lower)_cc_CFLAGS) -Wnested-externs -Wstrict-prototypes -Wmissing-prototypes


# Flags for faster code.
cc_fast_CFLAGS = $($(cc_name)_$(os_lower)_cc_fast_CFLAGS)


#######

# Compiler- and OS-specific flags.

# GCC on GNU/Linux:
gcc_linux_common_CFLAGS		:= -Wextra -Wmissing-declarations -Wunsafe-loop-optimizations -Wno-type-limits
gcc_linux_common_fast_CFLAGS	:= -Ofast -march=native -funsafe-loop-optimizations
gcc_linux_cc_CFLAGS		:= -Wno-unsuffixed-float-constants -Wno-unused-result
gcc_linux_cc_fast_CFLAGS	:=

# GCC on Darwin (i.e., Mac OS X):
gcc_darwin_common_CFLAGS	:= -Wunsafe-loop-optimizations -Wmissing-field-initializers -Wempty-body -Wno-strict-aliasing
gcc_darwin_common_fast_CFLAGS	:= -fast -funsafe-loop-optimizations
gcc_darwin_cc_CFLAGS		:= -Wmissing-declarations
gcc_darwin_cc_fast_CFLAGS	:=

# Clang on GNU/Linux:
clang_linux_common_CFLAGS	:= -Wextra -Wmissing-declarations -Qunused-arguments -Wno-tautological-compare -Wno-type-limits \
					-Wno-unknown-warning-option
clang_linux_common_fast_CFLAGS	:= -Ofast -march=native
clang_linux_cc_CFLAGS		:= -Wno-unused-result
clang_linux_cc_fast_CFLAGS	:=

# Clang on Darwin (i.e., Mac OS X):
clang_darwin_common_CFLAGS	:= -Wextra -Wmissing-declarations -Qunused-arguments -Wno-tautological-compare -Wno-type-limits \
					-Wno-unknown-warning-option
clang_darwin_common_fast_CFLAGS	:= -O4 -march=native -funsafe-loop-optimizations
clang_darwin_cc_CFLAGS		:= -Wno-unused-result
clang_darwin_cc_fast_CFLAGS	:=


########################################

# MPI compiler
default_MPICC := mpicc

ifneq ($(filter default undefined,$(origin MPICC)),)
	override MPICC := $(default_MPICC)
else
	# Just in case the user tried to undefine MPICC by assigning an empty value
	# (rather than use the "unset" command).
	ifeq (${MPICC},)
		override MPICC := $(default_MPICC)
	endif
endif

########################################

# CUDA compiler
default_NVCC := nvcc

ifneq ($(filter default undefined,$(origin NVCC)),)
	override NVCC := $(default_NVCC)
else
	# Just in case the user tried to undefine NVCC by assigning an empty value
	# (rather than use the "unset" command).
	ifeq (${NVCC},)
		override NVCC := $(default_NVCC)
	endif
endif

user_cuda_compiler := ${NVCC}

# File not found, searches in PATH.
ifeq ($(wildcard ${NVCC}),)

	# No folder names in PATH with whitespace characters. Uses the fast version.
	ifeq ($(words ${PATH}),1)
		new_nvcc := $(call fast_pathsearch,${NVCC})

	else	# Slower version that supports whitespace characters in folder names.
		do_not_care := $(call whitespace_pathsearch,${NVCC},new_nvcc)
	endif

	# Overrides the old value. Empty string if not found in PATH.
	override NVCC := $(new_nvcc)
endif


# Path to the CUDA Toolkit
cuda_home := $(call whitespaced_path,dir,${NVCC})/..

# CUDA headers folder
nvcc_includedir := $(cuda_home)/include

# CUDA libraries folder
nvcc_libdir := $(wildcard $(cuda_home)/lib$(os_size))
ifeq ($(nvcc_libdir),)	# Previous path not found. Sets a new one.
	nvcc_libdir := $(wildcard $(cuda_home)/lib)
endif


# Error message to show if no path to CUDA Toolkit was found.
nvcc_not_found_message := "\n\
	ERROR:\n\
	Could not find: '$(user_cuda_compiler)'.\n\
	\n\
	Please specify a path to a CUDA compiler, either by using the argument \"NVCC\",\n\
	or by adding it to your PATH environment variable. In addition, please remember\n\
	that paths with whitespace characters must be surrounded by single or double\n\
	quotes, *AND* be properly escaped with '\\'.\n\
	\n\
	For instance:\n\
		\tmake  NVCC:=\"/opt/cuda\ toolkit/bin/$(default_NVCC)\"\n"


#########

# Flags for NVCC (may be modified later according to input parameters).
nvcc_CFLAGS	 := --restrict --optimize 3 --disable-warnings
nvcc_fast_CFLAGS := --use_fast_math
nvcc_CPPFLAGS	 :=


# Internal compiler for HOST code (e.g., kernels launch).
#	Useful to make NVCC to follow a customized CC variable (e.g., CC='gcc-4.2').
#	Otherwise, CC is ignored and the default C/C++ compiler is invoked ('gcc' for Linux, 'clang' for Darwin, and 'cl.exe' for Windows).
nvcc_CFLAGS	 += --compiler-bindir ${CC}


## Useful options for CygWin and Mingw, respectively, under MS Windows platforms.
#
# nvcc_CFLAGS += --drive-prefix /cygwin/
# nvcc_CFLAGS += --drive-prefix /


## To specify the version of Microsoft Visual Studio installation (e.g., 2012).
# nvcc_CFLAGS += --use-local-env --cl-version 2008


#########

# Flags for nvopencc, which generates PTX (intermediate) code on Compute Capability 1.x.
opencc_CFLAGS := -W
opencc_fast_CFLAGS  := -ffast-stdlib -ffast-math -inline

# Many options for opencc are similar to those in common_CFLAGS, but not all.
# They will be removed later from opencc_CFLAGS.
not_in_opencc := -Wextra -Wstrict-overflow% -W%type-limits -mfpmath=% -msse4.% -W%unsuffixed-float-constants \
		-march=% -f%branch-target-load-optimize -f%branch-target-load-optimize2 -Ofast% -fast -fpch% -W%pch -f%pch \
		-f%unsafe-loop-optimizations -Wunknown-% -Wno-unknown-% -Qunused-% -W%tautological-compare -W%missing-field-initializers


#########

# Flags for PTX code compilation, which generates the actual GPU assembler.

ptxas_CFLAGS	  := #--warning-as-error 0
ptxas_fast_CFLAGS := --opt-level=4 --allow-expensive-optimizations=true
ptxas_warn_CFLAGS := --generate-line-info --verbose

# # Additional flags to control cache policy:
# ptxas_fast_CFLAGS += --def-load-cache=ca --def-store-cache=wb


#########

##
 # Target GPU architectures.
 #
 #	Device code is compiled in two stages. First, the compiler emits an assembler
 #	code (named "PTX") for a virtual device that represents a class of GPU models
 #	with similar features and/or architecture. In the second stage, such PTX code
 #	is then compiled in order to generate executable code for a particular (real)
 #	device from the former GPU class.
 #
 #	Virtual architectures are named "compute_XY", while real GPU models are denoted
 #	as "sm_XY". In both terms, the two-digits value "XY" represents the Compute
 #	Capability "X.Y".
 #
 #	Note that both architectures must be compatible. That is, PTX code emitted for
 #	a "compute_XY" GPU class can be compiled and executed on a "sm_WZ" device, if
 #	and only if, XY <= WZ. For instance, 'compute_13' is NOT compatible with 'sm_10',
 #	because the former architecture assumes the availability of features not
 #	present on devices of Compute Capability 1.0, but on 1.3 and beyond.
 #
 #	In the following rules, the 'arch=' clause must always be of type "compute_XY",
 #	while the 'code=' clause can either be "compute_XY", "sm_XY", or both. Note
 #	that only target versions specified in the latter clause will be retained in
 #	the output file.
 #
 #	For a detailed description of concepts above, please see "GPU Compilation" in
 #	the "CUDA Compiler Driver NVCC" reference guide, which can be found in the 'doc'
 #	folder of your CUDA Toolkit, or at URL:
 #	http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#gpu-compilation
##

# Generates PTX and executable code, for the specified "real" device.
# However, only the latter is kept.
gencode_real_template = --generate-code=arch=compute_$(1),code=sm_$(2)

# Emits PTX code, which is embedded into the executable file.
# Compilation will be performed at runtime according to the actual device.
gencode_virtual_template = --generate-code=arch=compute_$(1),code=compute_$(1)


# Calls gencode_real_template() with similar or different values for PTX and executable code.
sm_real_template = $(call gencode_real_template,$(firstword $(1)),$(lastword $(1)))

# Calls gencode_virtual_template(), previously removing the prefix 'PTX' from the argument.
sm_virtual_template = $(call gencode_virtual_template,$(subst PTX,,$(1)))


# Calls sm_real_template for each value in SM_VERSIONS, previously removing any dash.
# Values prefixed with 'PTX' are also removed.
sm_CFLAGS := $(foreach sm_ver,$(filter-out PTX%,${SM_VERSIONS}),$(call sm_real_template,$(subst -, ,$(sm_ver))))

# Calls sm_virtual_template for each value in SM_VERSIONS prefixed with 'PTX'.
# Non-prefixed values are previously removed.
sm_CFLAGS += $(foreach sm_ver,$(filter PTX%,${SM_VERSIONS}),$(call sm_virtual_template,$(sm_ver)))


#####


# Double-precision operations are NOT natively supported on Compute Capability < 1.3

# Searches for unsupported Compute Capabilities.
unsupported_sm_versions := $(filter 10 11 12,$(subst -, ,${SM_VERSIONS}))

# Warning message to show.
# NOTE:
#	* Literal tabs and newline characters are ignored. Only '\t' and '\n' are printed.
#	* Only double quotes (") need to be escaped, if any.
unsupported_sm_versions_message := "\n\
	WARNING:\n\
	On Compute Capability < 1.3, double-precision arithmetic operations are\n\
	demoted to single precision. In addition, accesses to shared memory will be\n\
	split into two requests with bank conflicts.\n"

#####

# Warning message for incorrect parameter 'SM_VERSION' (i.e., in singular form).
# NOTE:
#	* Literal tabs and newline characters are ignored. Only '\t' and '\n' are printed.
#	* Only double quotes (") need to be escaped, if any.
unknown_sm_version_message := "\n\
	Error:\n\
	Unknown parameter \"SM_VERSION\".\n\
	Did you mean 'SM_VERSIONS' (i.e., in the plural form) ?\n"



########################################
# User Makefile parameters.
########################################

# Uses single-precision data.
ifeq (${SINGLE},1)
	common_CPPFLAGS += -DNMFGPU_SINGLE_PREC=1
else
	# Just in case it was not defined.
	SINGLE := 0
endif


# Uses unsigned integers for matrix dimensions
ifeq (${UNSIGNED},1)
	common_CPPFLAGS += -DNMFGPU_UINDEX=1
else
	# Just in case it was not defined.
	UNSIGNED := 0
endif


# Uses faster math functions
ifeq (${FAST_MATH},1)
	cc_CFLAGS	:= $(filter-out -O%,$(cc_CFLAGS)) $(cc_fast_CFLAGS)
	common_CFLAGS	:= $(filter-out -O%,$(common_CFLAGS)) $(common_fast_CFLAGS)

	# Removes "--optimize <number>" from nvcc_CFLAGS.
	tmp := $(subst --optimize$(space),--optimize__,$(nvcc_CFLAGS))
	nvcc_CFLAGS	:= $(filter-out --optimize__%,$(tmp))
	nvcc_CFLAGS	+= $(nvcc_fast_CFLAGS)

	opencc_CFLAGS	+= $(opencc_fast_CFLAGS)
	ptxas_CFLAGS	+= $(ptxas_fast_CFLAGS)
else
	# Just in case it was not defined.
	FAST_MATH := 0
endif


# Show total elapsed time
ifeq (${TIME},1)
	common_CPPFLAGS += -DNMFGPU_PROFILING_GLOBAL=1
else
	# Just in case it was not defined.
	TIME := 0
endif


# Shows time elapsed on data transfers
ifeq (${TRANSF_TIME},1)
	common_CPPFLAGS += -DNMFGPU_PROFILING_TRANSF=1
else
	# Just in case it was not defined.
	TRANSF_TIME := 0
endif


# Shows time elapsed on kernel code.
ifeq (${KERNEL_TIME},1)
	common_CPPFLAGS += -DNMFGPU_PROFILING_KERNELS=1
else
	# Just in case it was not defined.
	KERNEL_TIME := 0
endif


# Shows time elapsed on MPI communications.
ifeq (${COMM_TIME},1)
	common_CPPFLAGS += -DNMFGPU_PROFILING_COMM=1
else
	# Just in case it was not defined.
	COMM_TIME := 0
endif


# Performs SYNCHRONOUS data transfers.
ifeq (${SYNC_TRANSF},1)
	common_CPPFLAGS += -DNMFGPU_SYNC_TRANSF=1
else
	# Just in case it was not defined.
	SYNC_TRANSF := 0
endif


# Fixed initial values for W and H. Useful for debugging.
ifeq (${FIXED_INIT},1)
	common_CPPFLAGS += -DNMFGPU_FIXED_INIT=1
else
	# Just in case it was not defined.
	FIXED_INIT := 0
endif


# Generates values from the CPU (host) random generator,
# not from the GPU device.
ifeq (${CPU_RANDOM},1)
	common_CPPFLAGS += -DNMFGPU_CPU_RANDOM=1
else
	# Just in case it was not defined.
	CPU_RANDOM := 0
endif


# VERBOSE and DEBUG mode (prints A LOT of information)
ifeq (${DBG},1)
	common_CPPFLAGS += -DNMFGPU_VERBOSE=1 -DNMFGPU_DEBUG=1

	# Other DEBUG flags

	# Verbosity level
	common_CPPFLAGS += -DNMFGPU_VERBOSE_2=1

	# # Dumps all data transfers
	# common_CPPFLAGS += -DNMFGPU_DEBUG_TRANSF=1

	# # Forces a blockwise processing:
	# common_CPPFLAGS += -DNMFGPU_FORCE_BLOCKS=1

	# # Just shows blockwise-processing information and exits.
	# # No actual processing is performed
	# common_CPPFLAGS += -DNMFGPU_TEST_BLOCKS=1

	# # Dumps intermediate data from the matrix reduction routine.
	# common_CPPFLAGS += -DNMFGPU_DEBUG_REDUCT=1

	# # Flags for I/O Debug & testing.
	# common_CPPFLAGS += -DNMFGPU_DEBUG_READ_FILE=1
	# common_CPPFLAGS += -DNMFGPU_DEBUG_READ_FILE2=1
	# common_CPPFLAGS += -DNMFGPU_DEBUG_READ_MATRIX=1
	# common_CPPFLAGS += -DNMFGPU_DEBUG_READ_MATRIX2=1
	# common_CPPFLAGS += -DNMFGPU_DEBUG_WRITE_MATRIX=1
	# common_CPPFLAGS += -DNMFGPU_TESTING=1

	CC_WARN_VERBOSE := 1
	NVCC_WARN_VERBOSE := 1
	PTXAS_WARN_VERBOSE := 1

else
	# Just in case it was not defined.
	DBG := 0
endif


# Verbose compiling commands
ifeq (${VERBOSE},3)
	nvcc_CFLAGS += --verbose
	cmd_prefix :=
	cmd_prefix2 :=
else
	ifeq (${VERBOSE},2)
		cmd_prefix :=
		cmd_prefix2 :=
	else
		ifeq (${VERBOSE},1)
			cmd_prefix :=
		else
			cmd_prefix := @

			# Just in case it was not defined.
			VERBOSE := 0
		endif
		cmd_prefix2 := @
	endif
endif


# Shows extra warnings on code compiled by CC, including several "false-positive" warnings.
ifeq (${CC_WARN_VERBOSE},1)
	cc_CFLAGS := $(subst -Wno-,-W,$(cc_CFLAGS)) -Wextra
	common_CFLAGS := $(subst -Wno-,-W,$(common_CFLAGS)) -Wextra
else
	# Just in case it was not defined.
	CC_WARN_VERBOSE := 0
endif


# Shows extra warnings on code compiled by NVCC, including many "false-positive" warnings.
ifeq (${NVCC_WARN_VERBOSE},1)
	common_CFLAGS	:= $(subst -Wno-,-W,$(common_CFLAGS))
	nvcc_CFLAGS	:= $(filter-out --disable-warnings,$(nvcc_CFLAGS))

	PTXAS_WARN_VERBOSE := 1
else
	# Just in case it was not defined.
	NVCC_WARN_VERBOSE := 0
endif


# Shows kernel compilation warnings
ifeq (${PTXAS_WARN_VERBOSE},1)
	ptxas_CFLAGS += $(ptxas_warn_CFLAGS)
else
	# Just in case it was not defined.
	PTXAS_WARN_VERBOSE := 0
endif


# Keep intermediate code files.
ifeq (${KEEP_INTERMEDIATE},1)
	nvcc_CFLAGS += --keep
else
	# Just in case it was not defined.
	KEEP_INTERMEDIATE := 0
endif


########################################
# Final Compilation Flags
########################################

# CUDA device code
cuda_device_OBJS   := $(addprefix $(objdir)/,$(addsuffix .o,$(cuda_device_FILES)))

# Flags for NVCC
cuda_nvcc_CPPFLAGS  := $(nvcc_CPPFLAGS) $(common_CPPFLAGS) ${CPPFLAGS} ${NVCC_CPPFLAGS}
cuda_nvcc_CFLAGS    := $(nvcc_CFLAGS) $(sm_CFLAGS) $(addprefix --compiler-options ,$(common_CFLAGS) ${CXXFLAGS}) ${NVCC_CFLAGS}
cuda_nvcc_INCLUDES  := ${NVCC_INCLUDES} ${INCLUDES} --include-path $(includedir)
export OPENCC_FLAGS := $(opencc_CFLAGS) $(filter-out $(not_in_opencc),$(common_CFLAGS) ${CXXFLAGS}) ${OPENCC_FLAGS}
export PTXAS_FLAGS  := $(ptxas_CFLAGS) ${PTXAS_FLAGS}


######


# ISO-C code
iso_c_OBJS	:= $(addprefix $(objdir)/,$(addsuffix .o,$(iso_c_FILES)))

# CUDA host code
cuda_host_OBJS	 := $(addprefix $(objdir)/,$(addsuffix .o,$(cuda_host_FILES)))

# Flags for code compiled with CC
c_CPPFLAGS := $(common_CPPFLAGS) ${CPPFLAGS}
c_CFLAGS   := $(common_CFLAGS) $(cc_CFLAGS) ${CFLAGS}
c_INCLUDES := ${INCLUDES} -I$(includedir)

# Additional flags for CUDA host code compiled with CC
cuda_cc_INCLUDES := -I$(nvcc_includedir)
cuda_cc_CPPFLAGS := -DNMFGPU_CUDA_HOST=1


######


# Tools
tools_TARGETS	:= $(addprefix $(tools_bindir)/,$(basename $(notdir $(tools_FILES))))
tools_OBJS	:= $(addprefix $(tools_objdir)/,$(addsuffix .o,$(notdir $(tools_FILES))))
tools_DEPS	:= $(iso_c_OBJS)
tools_CPPFLAGS	:= $(c_CPPFLAGS)
tools_CFLAGS	:= $(c_CFLAGS)
tools_INCLUDES	:= $(c_INCLUDES)
tools_LDFLAGS	:= ${LDFLAGS} $(common_LDFLAGS)
tools_LDLIBS	:= ${LDLIBS} -lm


# Main Program (single-GPU version)
single_gpu_TARGET	:= $(bindir)/$(basename $(single_gpu_FILE))
single_gpu_OBJ		:= $(objdir)/$(single_gpu_FILE).o
single_gpu_DEPS		:= $(tools_DEPS) $(cuda_host_OBJS) $(cuda_device_OBJS)
single_gpu_CPPFLAGS	:= $(tools_CPPFLAGS) $(cuda_cc_CPPFLAGS)
single_gpu_CFLAGS	:= $(tools_CFLAGS)
single_gpu_INCLUDES	:= $(tools_INCLUDES) $(cuda_cc_INCLUDES)
single_gpu_LDFLAGS	:= $(tools_LDFLAGS) -L$(nvcc_libdir)
single_gpu_LDLIBS	:= ${LDLIBS} -lcublas -lcurand -lcudart -lm


# Main Program (multi-GPU version)
multi_gpu_TARGET	:= $(bindir)/$(basename $(multi_gpu_FILE))
multi_gpu_OBJ		:= $(objdir)/$(multi_gpu_FILE).o
multi_gpu_SRC		:= $(srcdir)/$(multi_gpu_FILE)
multi_gpu_DEPS		:= $(single_gpu_DEPS)
multi_gpu_CPPFLAGS	:= -DNMFGPU_MPI=1 $(single_gpu_CPPFLAGS) ${MPICC_CPPFLAGS}
multi_gpu_CFLAGS	:= $(single_gpu_CFLAGS) ${MPICC_CFLAGS}
multi_gpu_INCLUDES	:= ${MPICC_INCLUDES} $(single_gpu_INCLUDES)
multi_gpu_LDFLAGS	:= ${MPICC_LDFLAGS} $(single_gpu_LDFLAGS)
multi_gpu_LDLIBS	:= ${MPICC_LDLIBS} $(single_gpu_LDLIBS)


########################################
# Goals
########################################


# Compiles default programs
.PHONY: all
all : tools single_gpu


# Compiles ALL programs.
.PHONY: all_programs
all_programs : all multi_gpu


# Compiles the single-GPU version
.PHONY: single_gpu single_GPU
single_gpu single_GPU : compiling_single_gpu_message $(single_gpu_TARGET)


# Compiles the multi-GPU version
.PHONY: multi_gpu multi_GPU
multi_gpu multi_GPU : compiling_multi_gpu_message $(multi_gpu_TARGET)


# Compiles the utility programs
.PHONY: tools
tools : compiling_tools_message $(tools_TARGETS)


########################################
# Target-specific (linking) rules
########################################

# Main Program (multi-GPU version, C++ code)
$(multi_gpu_TARGET) : $(multi_gpu_DEPS) $(multi_gpu_OBJ) | check_sm_versions check_cuda_path $(dir $(multi_gpu_TARGET))/.sentinel
	$(cmd_prefix)${MPICC} $(multi_gpu_CPPFLAGS) $(multi_gpu_CFLAGS) $(multi_gpu_INCLUDES) $(multi_gpu_LDFLAGS) $^ $(multi_gpu_LDLIBS) -o $@


# Main Program (single-GPU version, C++ code)
$(single_gpu_TARGET) : $(single_gpu_DEPS) $(single_gpu_OBJ) | check_sm_versions check_cuda_path $(dir $(single_gpu_TARGET))/.sentinel
	$(cmd_prefix)${CC} $(single_gpu_CPPFLAGS) $(single_gpu_CFLAGS) $(single_gpu_INCLUDES) $(single_gpu_LDFLAGS) $^ $(single_gpu_LDLIBS) -o $@


# Tools
$(tools_bindir)/% : $(tools_DEPS) $(tools_objdir)/%.c.o | $(tools_bindir)/.sentinel
	$(cmd_prefix)${CC} $(tools_CPPFLAGS) $(tools_CFLAGS) $(tools_INCLUDES) $(tools_LDFLAGS) $^ $(tools_LDLIBS) -o $@


########################################
# Compilation rules
#
# NOTE/HACK:
# Tricks for dependencies, thanks to:
#	Auto-Dependency Generation [retrieved on February 2015]
#	http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/
########################################

# MPI code
$(multi_gpu_OBJ) : $(multi_gpu_SRC) | $(dir $(multi_gpu_OBJ))/.sentinel
	$(cmd_prefix2)${MPICC} $(multi_gpu_CPPFLAGS) $(multi_gpu_INCLUDES) -MT $@ -MM $< > $@.d
	$(cmd_prefix)${MPICC} $(multi_gpu_CPPFLAGS) $(multi_gpu_CFLAGS) $(multi_gpu_INCLUDES) -o $@ -c $<

-include $(multi_gpu_OBJ).d


# ISO-C and CUDA-host code

$(iso_c_OBJS) : | $(addsuffix /.sentinel,$(dir $(iso_c_OBJS)))
$(tools_OBJS) : | $(addsuffix /.sentinel,$(dir $(tools_OBJS)))
$(cuda_host_OBJS) : | $(addsuffix /.sentinel,$(dir $(cuda_host_OBJS)))
$(single_gpu_OBJ) : | $(addsuffix /.sentinel,$(dir $(single_gpu_OBJ)))
$(cuda_host_OBJS) $(single_gpu_OBJ) : c_INCLUDES += $(cuda_cc_INCLUDES)
$(cuda_host_OBJS) $(single_gpu_OBJ) : c_CPPFLAGS := $(cuda_cc_CPPFLAGS) $(c_CPPFLAGS)
$(objdir)/%.c.o : $(srcdir)/%.c
	$(cmd_prefix2)${CC} $(c_CPPFLAGS) $(c_INCLUDES) -MT $@ -MM $< > $@.d
	$(cmd_prefix)${CC} $(c_CPPFLAGS) $(c_CFLAGS) $(c_INCLUDES) -o $@ -c $<

-include $(addsuffix .d,$(tools_DEPS) $(tools_OBJS))


# CUDA device code
$(cuda_device_OBJS) : | check_sm_versions check_cuda_path $(addsuffix /.sentinel,$(dir $(cuda_device_OBJS)))
$(objdir)/%.cu.o : $(srcdir)/%.cu
	$(cmd_prefix2)${NVCC} $(cuda_nvcc_CPPFLAGS) $(cuda_nvcc_INCLUDES) --dependency-target-name $@ --generate-dependencies $< > $@.d
	$(cmd_prefix)${NVCC} $(cuda_nvcc_CPPFLAGS) $(cuda_nvcc_CFLAGS) $(cuda_nvcc_INCLUDES) --output-file $@ --compile $<

-include $(addsuffix .d,$(cuda_device_OBJS))


# Makes directories
# $(objdir)/$(matrix_io_dirname) $(tools_objdir) $(objdir) $(tools_bindir) $(bindir) :
%/.sentinel :
	-$(cmd_prefix2)$(call MKDIR_P,$(@D)) && touch $@



########################################
# Error-checking rules
########################################

# NVCC not found in PATH
.PHONY: check_cuda_path
check_cuda_path :
ifeq (${NVCC},)
	@echo $(nvcc_not_found_message) >&2
	@exit 1
endif


# Checks common pitfalls for SM_VERSIONS parameter.
.PHONY: check_sm_versions
check_sm_versions :
ifneq ($(SM_VERSION),)
	@echo $(unknown_sm_version_message) >&2
	@exit 1
endif
ifneq (${SINGLE},1)
ifneq ($(strip $(unsupported_sm_versions)),)
	@echo $(unsupported_sm_versions_message) >&2
endif
endif


########################################
# Cleaning-up rules
########################################

# Removes all directories containing executable and object files
.PHONY: clobber distclean realclean
clobber distclean realclean : clean
	-$(cmd_prefix)${RMDIR} $(bindir)


# Removes executable and object files generated by the corresponding target.
.PHONY: clobber_multi_gpu clobber_single_gpu clobber_tools
clobber_multi_gpu clobber_single_gpu clobber_tools : clobber_target=$(patsubst clobber_%,%,$@)
clobber_multi_gpu : clean_multi_gpu
clobber_single_gpu : clean_single_gpu
clobber_tools : clean_tools
	-$(cmd_prefix)${RM} $($(clobber_target)_TARGETS) $($(clobber_target)_TARGET)
	$(if $($(clobber_target)_bindir),-$(cmd_prefix)${RMDIR} $($(clobber_target)_bindir))


# Removes the folder containing all object (".o") files. Executable code is not affected.
.PHONY: clean
clean :
	-$(cmd_prefix)${RMDIR} $(objdir)


# Removes object files generated by the corresponding target. Executable code is not affected.
.PHONY: clean_multi_gpu clean_single_gpu clean_tools
clean_multi_gpu clean_single_gpu clean_tools : clean_target=$(patsubst clean_%,%,$@)
clean_multi_gpu clean_single_gpu clean_tools :
	-$(cmd_prefix)${RM} $($(clean_target)_OBJS) $($(clean_target)_OBJ) $($(clean_target)_DEPS) \
	$(addsuffix .d,$($(clean_target)_OBJS) $($(clean_target)_OBJ) $($(clean_target)_DEPS))
	$(if $($(clean_target)_objdir),-$(cmd_prefix)${RMDIR} $($(clean_target)_objdir))


########################################
# Rules for help messages
########################################

# Main help
.PHONY: help
help :
	@echo $(help_message)


# Help for 'SM_VERSIONS' parameter
.PHONY: help_sm_versions help_SM_Versions help_SM_VERSIONS
help_sm_versions help_SM_Versions help_SM_VERSIONS :
	@echo $(help_sm_versions_message)


# Help for utility programs
.PHONY: help_tools help_Tools
help_tools help_Tools :
	@echo $(help_tools_message)


########################################
# Help Messages
########################################

# Main help message

help_message := "\n\
 Makefile for NMF-mGPU on UNIX systems.\n\
 \n\
 List of available goals:\n\
	\n\
	\tall:\t\tDEFAULT target. Compiles all programs, EXCEPT the\n\
			\t\t\tmulti-GPU version.\n\
	\n\
	\tall_programs:\tCompiles all programs, including the multi-GPU version.\n\
	\n\
	\tmulti_gpu:\tCompiles the multi-GPU version. Target NOT compiled by\n\
			\t\t\tdefault.\n\
	\n\
	\tsingle_gpu:\tCompiles the single-GPU version.\n\
	\n\
	\ttools:\t\tCompiles some utility programs.\n\
			\t\t\tThis target does NOT require any CUDA-related software\n\
			\t\t\tor configuration. In addition, it is NOT necessary to\n\
			\t\t\tspecify the parameters: 'CUDA_HOME' or 'SM_VERSIONS'.\n\
	\n\
	\n\
 Other useful targets:\n\
	\n\
	\tclean:\t\tRemoves the folder containing all object (\".o\") files.\n\
			\t\t\tExecutable code is not affected.\n\
	\n\
	\tclean_single_gpu, clean_multi_gpu, clean_tools:\n\
			\t\t\tRemoves object files generated by the corresponding\n\
			\t\t\ttarget. Executable code is not affected.\n\
	\n\
	\tclobber, distclean, realclean:\n\
			\t\t\tRemoves all directories containing executable and object\n\
			\t\t\tfiles.\n\
	\n\
	\tclobber_single_gpu, clobber_multi_gpu, clobber_tools:\n\
			\t\t\tRemoves the executable and object files generated by the\n\
			\t\t\tcorresponding target. Executable code is not affected.\n\
	\n\
	\thelp:\t\tPrints this help message.\n\
	\n\
	\thelp_sm_versions:\n\
			\t\t\tPrints a detailed description of he 'SM_VERSIONS'\n\
			\t\t\tparameter.\n\
	\n\
	\thelp_tools:\tPrints a short description of available utility programs\n\
	\n\
	\n\
 List of available parameters:\n\
	\n\
	\tSM_VERSIONS:\tTarget GPU architecture. This parameter may be an\n\
		\t\t\tenvironment variable or an argument. Device code will be\n\
		\t\t\tgenerated for the specified \"Compute Capability\" (CC).\n\
		\t\t\tFor instance, 'SM_VERSIONS=\"10-13  30  PTX35\"':\n\
		\t\t\t* Generates device-specific executable code for CC 1.3,\n\
		\t\t\t  using only the basic functionality present on CC 1.0.\n\
		\t\t\t* Generates device-specific executable code for CC 3.0,\n\
		\t\t\t  using all available features on such architecture.\n\
		\t\t\t* Emits PTX code for CC 3.5, which can be later\n\
		\t\t\t  compiled and executed by any actual or future device,\n\
		\t\t\t  with a similar or higher Compute Capability.\n\
		\t\t\tTo generate device-specific executable code for CC 2.1,\n\
		\t\t\tplease specify it as: '20-21'.\n\
		\t\t\tSee a more detailed description of this parameter by\n\
		\t\t\texecuting:\n\
		\t\t\t\tmake help_sm_versions\n\
		\t\t\tThis parameter is currently ignored on the 'tools'\n\
		\t\t\ttarget.\n\
		\t\t\tDefault value(s): \"${SM_VERSIONS}\".\n\
	\n\
	\tSINGLE:\t\tIf set to '1', uses single-precision data (ie, 'float').\n\
		\t\t\tOtherwise, uses double-precision (i.e., 'double').\n\
		\t\t\tWARNING: On Compute Capability < 1.3, double-precision\n\
		\t\t\tarithmetic operations are demoted to single precision.\n\
		\t\t\tIn addition, accesses to shared memory will be split\n\
		\t\t\tinto two requests with bank conflicts.\n\
		\t\t\tDefault value: '${SINGLE}'.\n\
	\n\
	\tUNSIGNED:\tUses unsigned integers for matrix dimensions, which may\n\
		\t\t\tgenerate faster code. Nevertheless, please note that\n\
		\t\t\tCUBLAS library functions use SIGNED-integer parameters.\n\
		\t\t\tTherefore, matrix dimensions must not overflow such data\n\
		\t\t\ttype. An error message will be shown if this happens.\n\
		\t\t\tDefault value: '${UNSIGNED}'.\n\
	\n\
	\tFAST_MATH:\tUses less-precise faster math functions. Default: '${FAST_MATH}'.\n\
	\n\
	\tTIME:\t\tShows total elapsed time. Default value: '${TIME}'.\n\
	\n\
	\tTRANSF_TIME:\tShows time elapsed on data transfers. Default: '${TRANSF_TIME}'.\n\
	\n\
	\tKERNEL_TIME:\tShows time elapsed on kernel code. Default value: '${KERNEL_TIME}'.\n\
	\n\
	\tCOMM_TIME:\tShows time elapsed on MPI communications. Default: '${COMM_TIME}'.\n\
	\n\
	\tSYNC_TRANSF:\tPerforms SYNCHRONOUS data transfers. Default value: '${SYNC_TRANSF}'.\n\
	\n\
	\tFIXED_INIT:\tMakes use of \"random\" values from a fixed seed.\n\
		\t\t\tDefault value: '${FIXED_INIT}'.\n\
	\n\
	\tCPU_RANDOM:\tGenerates random values from the CPU host, not from the\n\
		\t\t\tGPU device. Default value: '${CPU_RANDOM}'.\n\
	\n\
	\tDBG:\t\tVERBOSE and DEBUG mode (prints A LOT of information).\n\
		\t\t\tIt implies CC_WARN_VERBOSE, NVCC_WARN_VERBOSE, and\n\
		\t\t\tPTXAS_WARN_VERBOSE set to '1'.\n\
		\t\t\tDefault value: '${DBG}'.\n\
	\n\
	\tVERBOSE:\tCommand-line verbosity level. Valid values are '0'\n\
		\t\t\t(none), '1' (shows make compilation commands), '2'\n\
		\t\t\t(shows all make and shell commands), and '3' (shows all\n\
		\t\t\tmake, shell, and NVCC commands). Default value: '${VERBOSE}'.\n\
	\n\
	\tCC_WARN_VERBOSE:\n\
		\t\t\tShows extra warning messages on programs compiled with\n\
		\t\t\tCC. Please note that it may include \"false-positive\"\n\
		\t\t\twarnings. Default value: '${CC_WARN_VERBOSE}'.\n\
	\n\
	\tNVCC_WARN_VERBOSE:\n\
		\t\t\tShows extra warning messages on programs compiled with\n\
		\t\t\tNVCC. Please note that it may include \"false-positive\"\n\
		\t\t\twarnings. It implies PTXAS_WARN_VERBOSE set to '1'.\n\
		\t\t\tDefault value: '${NVCC_WARN_VERBOSE}'.\n\
	\n\
	\tPTXAS_WARN_VERBOSE:\n\
		\t\t\tShows PTX-specific compilation warnings. Default: '${PTXAS_WARN_VERBOSE}'.\n\
	\n\
	\tKEEP_INTERMEDIATE:\n\
		\t\t\tKeeps temporary files generated by NVCC. Default: '${KEEP_INTERMEDIATE}'.\n\
	\n\
	\n\
 Default compilers can be overridden with following parameters or environment\n\
 variables:\n\
	\n\
	\tCC:\t\tCompiler for ISO-C and CUDA-host code. Used also in the\n\
		\t\t\tlinking stage of targets \"single_gpu\" and \"tools\".\n\
		\t\t\tSupported compilers: 'gcc' and 'clang'. Default: '$(default_CC)'.\n\
	\n\
	\tNVCC:\t\tCompiler for CUDA device code. Default value: '$(default_NVCC)'.\n\
		\t\t\tWARNING: Paths containing whitespace characters must be\n\
		\t\t\tsurrounded by double/single quotes, *AND* be properly\n\
		\t\t\tescaped with '\\'.\n\
		\t\t\tFor instance:\n\
		\t\t\t\tNVCC:=\"/opt/cuda\ toolkit/bin/$(default_NVCC)\"\n\
	\n\
	\tMPICC:\t\tCompiler for MPI code. Default value: '$(default_MPICC)'.\n\
	\n\
	\n\
 Additional flags, not affected by other input parameters, can be specified\n\
 through the following parameters or environment variables:\n\
	\n\
	\tCPPFLAGS, CFLAGS, INCLUDES, LDFLAGS, LDLIBS:\n\
		\t\t\tAdditional flags included in all targets.\n\
		\t\t\tNote: \"CFLAGS\" is IGNORED by NVCC. Instead, please make\n\
		\t\t\tuse of 'CXXFLAGS' and/or 'NVCC_CFLAGS' (see below).\n\
	\n\
	\tCXXFLAGS:\tAdditional options controlling the NVCC's internal\n\
		\t\t\tcompiler. Each word is automatically prefixed by\n\
		\t\t\t'--compiler-options' in the command line.\n\
		\t\t\tParameter is ignored on files not compiled with NVCC.\n\
	\n\
	\tNVCC_CPPFLAGS, NVCC_CFLAGS, NVCC_INCLUDES:\n\
		\t\t\tAdditional options for NVCC.\n\
	\n\
	\tOPENCC_FLAGS:\tAdditional flags for 'nvopencc', which generates PTX\n\
		\t\t\t(intermediate) code on devices of Compute Capability 1.x\n\
		\t\t\tParameter ignored on newer GPU architectures.\n\
	\n\
	\tPTXAS_FLAGS:\tAdditional flags for PTX code compilation, which\n\
		\t\t\tgenerates the actual GPU assembler.\n\
	\n\
	\tMPICC_CPPFLAGS, MPICC_CFLAGS, MPICC_INCLUDES, MPICC_LDFLAGS,\n\
	\tMPICC_LDLIBS:\n\
		\t\t\tAdditional flags for MPICC.\n"


####################

# Help message for SM_VERSIONS.

help_sm_versions_message := "\n\
 The SM_VERSIONS parameter:\n\
 \n\
 Device code is compiled in two stages. First, the compiler emits an assembler\n\
 code (named \"PTX\") for a virtual device that represents a class of GPU models\n\
 with similar features and/or architecture. In the second stage, such PTX code\n\
 is then compiled in order to generate executable code for a particular (real)\n\
 device from the former GPU class.\n\
 \n\
 Virtual architectures are named \"compute_XY\", while real GPU models are denoted\n\
 as \"sm_XY\". In both terms, the two-digits value \"XY\" represents the Compute\n\
 Capability \"X.Y\".\n\
 \n\
 Note that both architectures must be compatibles. That is, PTX code emitted for\n\
 a \"compute_XY\" GPU class can be compiled and executed on a \"sm_WZ\" device, if\n\
 and only if, XY <= WZ. For instance, compute_13 is NOT compatible with sm_10,\n\
 because the former architecture assumes the availability of features not\n\
 present on devices of Compute Capability 1.0, but on 1.3 and beyond.\n\
 \n\
 For a detailed description of concepts above, please see \"GPU Compilation\" in\n\
 the \"CUDA Compiler Driver NVCC\" reference guide, which can be found in the doc\n\
 folder of your CUDA Toolkit, or at URL:\n\
 http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html\#gpu-compilation\n\
 \n\
 \n\
 There are three ways to specify target architecture(s) in the SM_VERSIONS\n\
 parameter:\n\
 \n\
 1) Device-specific features & code (i.e., PTX and executable code, with SIMILAR\n\
	" "  Compute Capability):\n\
	\n\
	" "  Emits PTX assembler code, which is then compiled into executable\n\
	" "  instructions just for the given \"Compute Capability(-ies)\" (CC). Since the\n\
	" "  former is just an intermediate code (i.e., it is NOT retained in the output\n\
	" "  file), and the latter is generated with a device-specific binary format, the\n\
	" "  program may not be compatible with other GPU architectures. That is, any\n\
	" "  given CC value, \"XY\", is translated to the following NVCC option:\n\
	" "  \t\"--generate-code=arch=compute_<XY>,code=sm_<XY>\".\n\
	\n\
	" "  For instance, 'SM_VERSIONS=\"13  35\"' generates executable code just for\n\
	" "  devices of Compute Capability 1.3 and 3.5, respectively. GPU devices with\n\
	" "  other CC values, such as 1.1 or 2.0, may not be able to execute the program.\n\
	\n\
	" "  NOTE:\n\
	" "  For devices, such as 2.1, that do not have a similar PTX CC number, please\n\
	" "  specify the nearest lower value (\"2.0\", for the previous example) by using\n\
	" "  the dashed-separated form below.\n\
	\n\
	\n\
 2) Generic features, device-specific code (i.e., PTX and executable code, with\n\
	" "  DIFFERENT Compute Capabilities):\n\
	\n\
	" "  This is a generalization of the previous form. Here, different \"Compute\n\
	" "  Capabilities\" (CC) can be specified for both, PTX and executable code,\n\
	" "  separated by a dash. That is, \"XY-WZ\" (with XY <= WZ), emits PTX assembler\n\
	" "  code for CC \"X.Y\", which is then compiled into executable instructions for\n\
	" "  a device of CC \"W.Z\". The former, determines the target ARCHITECTURE (i.e.,\n\
	" "  the available hardware/ software features and functionality). The latter,\n\
	" "  specifies the target DEVICE in terms of binary code format.\n\
	\n\
	" "  Similarly as above, no PTX code is embedded in the output file, so the\n\
	" "  program may not be compatible with other GPU device models. That is, the\n\
	" "  previous expression is translated to the following NVCC option:\n\
	" "  \t\"--generate-code=arch=compute_<XY>,code=sm_<WZ>\".\n\
	\n\
	" "  Note that \"XY-XY\" is equivalent to just specify \"XY\" as in the previous form\n\
	" "  On the other hand, if XY < WZ, the program is still compiled for the target\n\
	" "  device (i.e. CC \"W.Z\"), but it will only make use of features available on\n\
	" "  CC \"X.Y\", discarding any functionality introduced since.\n\
	\n\
	" "  NOTE:\n\
	" "  As stated above, please use this form to specify target devices, such as\n\
	" "  CC 2.1, that do not have a similar PTX CC number (so, a lower value must\n\
	" "  also be given). Example: '20-21'.\n\
	\n\
	" "  For instance, 'SM_VERSIONS=\"10-13  20-21\"':\n\
		\n\
		\t* Generates executable code for a device of CC 1.3, with the basic\n\
		\t  features that are available on CC 1.0. In particular, it discards all\n\
		\t  support for double-precision floating-point data, introduced on CC 1.3\n\
		\t* Compiles the algorithm with the features and functionality available\n\
		\t  on CC 2.0, and generates a binary image for a device of CC 2.1.\n\
		\t* Since no PTX code is retained in the output file, the program may not\n\
		\t  compatible with other GPU devices (e.g., CC 3.0).\n\
	\n\
	\n\
 3) Generic features and \"code\":\n\
	\n\
	" "  Emits PTX assembler code for the given \"Compute Capability\" (CC), and\n\
	" "  embeds it into the output file. No executable code is generated. Instead,\n\
	" "  the former is dynamically compiled at runtime according to the actual GPU\n\
	" "  device. Such process is known as \"Just-in-Time compilation\" (JIT).\n\
	\n\
	" "  To specify a target architecture in a such way, please use the word 'PTX'\n\
	" "  followed by the target Compute Capability.\n\
	" "  That is,\n\
			\t\t\"PTX<wz>\"\n\
	\n\
	" "  generates PTX code for Compute Capability \"w.z\", and embeds it into the\n\
	" "  output file. Such code can be later compiled and executed on any device,\n\
	" "  with a similar or greater CC value. Similarly as previous forms, the\n\
	" "  expression above is translated to the following NVCC option:\n\
	" "  \"--generate-code=arch=compute_<wz>,code=compute_<wz>\".\n\
	\n\
	" "  Note, however, that JIT compilation increases the startup delay. In\n\
	" "  addition, the final executable code will use just those architectural\n\
	" "  features that are available on CC \"w.z\", discarding any functionality\n\
	" "  introduced since.\n\
	\n\
	" "  For instance, 'SM_VERSIONS=\"PTX10  PTX35\"':\n\
		\n\
		\t* Emits PTX code for the first CUDA-capable architecture (ie., CC 1.0).\n\
		\t  Therefore, the program can be later dynamically compiled and executed\n\
		\t  on ANY current or future GPU device. Nevertheless, it will only use\n\
		\t  the (very) basic features present on such architecture.\n\
		\t* Generates PTX code that can be later compiled and executed on devices\n\
		\t  of CC 3.5, or higher.\n\
		\t* Any device prior to CC 3.5 (e.g., 1.3, 2.1, or 3.0), will execute the\n\
		\t  basic CC 1.0 version.\n\
	\n\
	\n\
 Warning:\n\
	\t* On Compute Capability < 1.3, double-precision arithmetic operations\n\
	\t  are demoted to single precision. In addition, accesses to shared\n\
	\t  memory will be split into two requests with bank conflicts.\n\
	\t* Compute Capabilities 1.x are DEPRECATED since CUDA Toolkit version 7.0\n\
	\t  (Compute Capability 1.0 since CUDA version 6.0).\n\
	\t* This parameter is currently ignored by the 'tools' target.\n\
 \n\
 \n\
 Current default value(s):\n\
 \n\
	\t\"$(subst $(space),  ,${SM_VERSIONS})\",\n\
 \n\
 which will be translated into the following argument(s) for NVCC:\n\
 \n\
	\t$(subst $(space),\n\t,$(sm_CFLAGS))\n"


####################

# Help message for tools.

help_tools_message := "\n\
 Tool programs:\n\
 \n\
 In addition to \"NMF-mGPU\", there are some utility programs to make easier\n\
 working with input files. It includes a program for binary-text file conversion\n\
 and another to generate input matrices with random data (useful for testing).\n\
 \n\
 List of generated files:\n\
	\t$(subst $(space),\n\t,$(tools_TARGETS))\n\
 \n\
 NOTE: Tool programs do NOT make use of the GPU device. They have been\n\
 implemented in pure ISO-C language, so all operations are performed on the HOST\n\
 (i.e., the CPU). Therefore, they do NOT require any CUDA-related option,\n\
 configuration or software. In addition, it is NOT necessary to specify the\n\
 Makefile parameters: 'CUDA_HOME' or 'SM_VERSIONS'.\n\
 \n\
 1) Binary-text file converter:\n\
	" "  Since \"NMF-mGPU\" accepts input matrices stored in a binary or ASCII-text\n\
	" "  file, this program allows file conversion between both formats. For binary\n\
	" "  files, there are two sub-formats: \"native\" and \"non-native\".\n\
 \n\
		\t* "Non-Native" mode: Matrix data are stored using DOUBLE-precision values,\n\
		\t  and 32-bits UNSIGNED integers for matrix dimensions. If necessary, all\n\
		\t  values must be converted to LITTLE-endian format before writing to\n\
		\t  file. Finally, the file also contains a "binary signature", which will\n\
		\t  be checked when reading to make sure it is a valid input file.\n\
 \n\
		\t* "Native" mode: Matrix data are stored in RAW format according to the\n\
		\t  selected compilation parameters. That is, 'float' values if the\n\
		\t  program was compiled in SINGLE-precision mode (i.e., if the Makefile\n\
		\t  parameter "SINGLE" was set to '1'), and 'double' otherwise. Matrix\n\
		\t  dimensions are stored in a similar way: 'unsigned int' if "UNSIGNED" was\n\
		\t  set to '1', and '[signed] int' otherwise. Finally, all data is stored\n\
		\t  with the native endianness.\n\
		\n\
 2) Matrix generator:\n\
	" "  This program generates a data matrix with non-negative random values. The\n\
	" "  output file can be used as a valid input dataset for NMF-mGPU. You can\n\
	" "  specify the output matrix dimensions, as well as the highest possible random\n\
	" "  number (i.e., all values will be generated in the closed range between 0.0\n\
	" "  and the selected value, both inclusive). The output matrix can be written as\n\
	" "  ASCII text, or in a binary file (in any of the binary modes described above.\n\
	" "  WARNING: Output matrix will NOT contain any tag (i.e., neither of row\n\
	" "  labels, column headers nor a description string), just numeric data.\n"


########################################
# Compiling messages
########################################

.PHONY: compiling_multi_gpu_message
compiling_multi_gpu_message :
	@echo "\nCompiling the multi-GPU version for the following GPU architecture(s): $(SM_VERSIONS) ..."


.PHONY: compiling_single_gpu_message
compiling_single_gpu_message :
	@echo "\nCompiling the single-GPU version for the following GPU architecture(s): $(SM_VERSIONS) ..."


.PHONY: compiling_tools_message
compiling_tools_message :
	@echo "\nCompiling the utility programs..."

########################################
